'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var send = require('@tinyhttp/send');
var cookie = require('@tinyhttp/cookie');
var cookieSignature = require('@tinyhttp/cookie-signature');
var mime = require('es-mime-types');
var req = require('@tinyhttp/req');
var esVary = require('es-vary');
var encodeUrl = require('@tinyhttp/encode-url');
var http = require('http');
var escapeHtml = require('escape-html');
var contentDisposition = require('@tinyhttp/content-disposition');
var path = require('path');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var escapeHtml__default = /*#__PURE__*/_interopDefaultLegacy(escapeHtml);

const charsetRegExp = /;\s*charset\s*=/;
const setHeader = (res) => (field, val) => {
    if (typeof field === 'string') {
        let value = Array.isArray(val) ? val.map(String) : String(val);
        // add charset to content-type
        if (field.toLowerCase() === 'content-type') {
            if (Array.isArray(value)) {
                throw new TypeError('Content-Type cannot be set to an Array');
            }
            if (!charsetRegExp.test(value)) {
                const charset = mime.charset(value.split(';')[0]);
                if (typeof charset === 'string')
                    value += '; charset=' + charset.toLowerCase();
            }
        }
        res.setHeader(field, value);
    }
    else {
        for (const key in field) {
            setHeader(res)(key, field[key]);
        }
    }
    return res;
};
const setLocationHeader = (req$1, res) => (url) => {
    let loc = url;
    // "back" is an alias for the referrer
    if (url === 'back')
        loc = req.getRequestHeader(req$1)('Referrer') || '/';
    // set location
    res.setHeader('Location', encodeUrl.encodeUrl(loc));
    return res;
};
const getResponseHeader = (res) => (field) => {
    return res.getHeader(field);
};
const setLinksHeader = (res) => (links) => {
    let link = res.getHeader('Link') || '';
    if (link)
        link += ', ';
    res.setHeader('Link', link +
        Object.keys(links)
            .map((rel) => '<' + links[rel] + '>; rel="' + rel + '"')
            .join(', '));
    return res;
};
const setVaryHeader = (res) => (field) => {
    esVary.vary(res, field);
    return res;
};
const setContentType = (res) => (type) => {
    const ct = type.indexOf('/') === -1 ? mime.lookup(type) : type;
    setHeader(res)('Content-Type', ct);
    return res;
};

const append = (res) => (field, value) => {
    const prevVal = getResponseHeader(res)(field);
    let newVal = value;
    if (prevVal && typeof newVal !== 'number' && typeof prevVal !== 'number') {
        newVal = Array.isArray(prevVal)
            ? prevVal.concat(newVal)
            : Array.isArray(newVal)
                ? [prevVal].concat(newVal)
                : [prevVal, newVal];
    }
    setHeader(res)(field, newVal);
    return res;
};

const setCookie = (req, res) => (name, value, options = {}) => {
    const secret = req.secret;
    const signed = options.signed || false;
    if (signed && !secret)
        throw new Error('cookieParser("secret") required for signed cookies');
    let val = typeof value === 'object' ? 'j:' + JSON.stringify(value) : String(value);
    if (signed)
        val = 's:' + cookieSignature.sign(val, secret);
    if (options.maxAge) {
        options.expires = new Date(Date.now() + options.maxAge);
        options.maxAge /= 1000;
    }
    if (options.path == null)
        options.path = '/';
    append(res)('Set-Cookie', `${cookie.serialize(name, String(val), options)}`);
    return res;
};
const clearCookie = (req, res) => (name, options) => {
    return setCookie(req, res)(name, '', Object.assign({}, { expires: new Date(1), path: '/' }, options));
};

const normalizeType = (type) => ~type.indexOf('/') ? acceptParams(type) : { value: mime.lookup(type), params: {} };
function acceptParams(str, index) {
    const parts = str.split(/ *; */);
    const ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };
    for (const part of parts) {
        const pms = part.split(/ *= */);
        if ('q' === pms[0])
            ret.quality = parseFloat(pms[1]);
        else
            ret.params[pms[0]] = pms[1];
    }
    return ret;
}
function normalizeTypes(types) {
    const ret = [];
    for (const type of types) {
        ret.push(normalizeType(type));
    }
    return ret;
}

const formatResponse = (req$1, res, next) => (obj) => {
    const fn = obj.default;
    if (fn)
        delete obj.default;
    const keys = Object.keys(obj);
    const key = keys.length > 0 ? req.getAccepts(req$1)(...keys) : false;
    setVaryHeader(res)('Accept');
    if (key) {
        res.setHeader('Content-Type', normalizeType(key).value);
        obj[key](req$1, res, next);
    }
    else if (fn) {
        fn();
    }
    else {
        const err = new Error('Not Acceptable');
        err.status = err.statusCode = 406;
        err.types = normalizeTypes(keys).map((o) => o.value);
        next(err);
    }
    return res;
};

const redirect = (req, res, next) => (url, status) => {
    let address = url;
    status = status || 302;
    let body;
    address = setLocationHeader(req, res)(address).getHeader('Location');
    formatResponse(req, res, next)({
        text: () => {
            body = http.STATUS_CODES[status] + '. Redirecting to ' + address;
        },
        html: () => {
            const u = escapeHtml__default['default'](address);
            body = `<p>${http.STATUS_CODES[status]}. Redirecting to <a href="${u}">${u}</a></p>`;
        },
        default: () => {
            body = '';
        }
    });
    res.setHeader('Content-Length', Buffer.byteLength(body));
    res.statusCode = status;
    if (req.method === 'HEAD')
        res.end();
    else
        res.end(body);
    return res;
};

const download = (res) => (path$1, filename, options, cb) => {
    let done = cb;
    let name = filename;
    let opts = (options || null);
    // support function as second or third arg
    if (typeof filename === 'function') {
        done = filename;
        name = null;
    }
    else if (typeof options === 'function') {
        done = options;
        opts = null;
    }
    // set Content-Disposition when file is sent
    const headers = {
        'Content-Disposition': contentDisposition.contentDisposition(name || path$1)
    };
    // merge user-provided headers
    if (opts && opts.headers) {
        for (const key of Object.keys(opts.headers)) {
            if (key.toLowerCase() !== 'content-disposition')
                headers[key] = opts.headers[key];
        }
    }
    // merge user-provided options
    opts = Object.create(opts);
    opts.headers = headers;
    // Resolve the full path for sendFile
    const fullPath = path.resolve(path$1);
    const noop = () => undefined;
    // send file
    return send.sendFile(res)(fullPath, opts, done || noop);
};
const attachment = (res) => (filename) => {
    if (filename)
        setContentType(res)(path.extname(filename));
    setHeader(res)('Content-Disposition', contentDisposition.contentDisposition(filename));
    return res;
};

Object.keys(send).forEach(function (k) {
  if (k !== 'default') Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return send[k];
    }
  });
});
exports.append = append;
exports.attachment = attachment;
exports.clearCookie = clearCookie;
exports.download = download;
exports.formatResponse = formatResponse;
exports.getResponseHeader = getResponseHeader;
exports.redirect = redirect;
exports.setContentType = setContentType;
exports.setCookie = setCookie;
exports.setHeader = setHeader;
exports.setLinksHeader = setLinksHeader;
exports.setLocationHeader = setLocationHeader;
exports.setVaryHeader = setVaryHeader;
