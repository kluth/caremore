export declare type NextFunction = (err?: any) => void;
export declare type SyncHandler<Request extends any = any, Response extends any = any> = (req: Request, res: Response, next?: NextFunction) => void;
export declare type AsyncHandler<Request extends any = any, Response extends any = any> = (req: Request, res: Response, next?: NextFunction) => Promise<void>;
export declare type Handler<Request extends any = any, Response extends any = any> = AsyncHandler<Request, Response> | SyncHandler<Request, Response>;
declare const METHODS: readonly ["ACL", "BIND", "CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LINK", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCALENDAR", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PRI", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REBIND", "REPORT", "SEARCH", "SOURCE", "SUBSCRIBE", "TRACE", "UNBIND", "UNLINK", "UNLOCK", "UNSUBSCRIBE"];
export declare type Method = typeof METHODS[number];
export declare type MiddlewareType = 'mw' | 'route';
declare type RegexParams = {
    keys: string[];
    pattern: RegExp;
};
export interface Middleware<Req extends any = any, Res extends any = any> {
    method?: Method;
    handler: Handler<Req, Res>;
    path?: string;
    type: MiddlewareType;
    regex?: RegexParams;
}
export declare type MethodHandler<Req extends any = any, Res extends any = any> = {
    path?: string | Handler<Req, Res>;
    handler?: Handler<Req, Res>;
    type: MiddlewareType;
    regex?: RegexParams;
};
export declare type RouterHandler<Req extends any = any, Res extends any = any> = Handler<Req, Res> | Handler<Req, Res>[];
export declare type RouterPathOrHandler<Req extends any = any, Res extends any = any> = string | RouterHandler<Req, Res>;
export declare type RouterMethod<Req extends any = any, Res extends any = any> = (path: string | Handler<Req, Res>, handler?: Handler<Req, Res>, ...handlers: Handler<Req, Res>[]) => any;
declare type RouterMethodParams<Req extends any = any, Res extends any = any> = Parameters<RouterMethod<Req, Res>>;
export declare type UseMethod<Req extends any = any, Res extends any = any, App extends Router = any> = (path: RouterPathOrHandler<Req, Res> | App, handler?: RouterHandler<Req, Res> | App, ...handlers: RouterHandler<Req, Res>[]) => any;
export declare type UseMethodParams<Req extends any = any, Res extends any = any, App extends Router = any> = Parameters<UseMethod<Req, Res, App>>;
/**
 * tinyhttp Router. Manages middleware and has HTTP methods aliases, e.g. `app.get`, `app.put`
 */
export declare class Router<App extends Router = any, Req extends any = any, Res extends any = any> {
    middleware: Middleware[];
    mountpath: string;
    parent: App;
    apps: Record<string, App>;
    get(...args: RouterMethodParams<Req, Res>): this;
    post(...args: RouterMethodParams<Req, Res>): this;
    put(...args: RouterMethodParams<Req, Res>): this;
    patch(...args: RouterMethodParams<Req, Res>): this;
    head(...args: RouterMethodParams<Req, Res>): this;
    delete(...args: RouterMethodParams<Req, Res>): this;
    options(...args: RouterMethodParams<Req, Res>): this;
    checkout(...args: RouterMethodParams<Req, Res>): this;
    copy(...args: RouterMethodParams<Req, Res>): this;
    lock(...args: RouterMethodParams<Req, Res>): this;
    unlock(...args: RouterMethodParams<Req, Res>): this;
    merge(...args: RouterMethodParams<Req, Res>): this;
    mkactivity(...args: RouterMethodParams<Req, Res>): this;
    mkcol(...args: RouterMethodParams<Req, Res>): this;
    move(...args: RouterMethodParams<Req, Res>): this;
    search(...args: RouterMethodParams<Req, Res>): this;
    msearch(...args: RouterMethodParams<Req, Res>): this;
    notify(...args: RouterMethodParams<Req, Res>): this;
    purge(...args: RouterMethodParams<Req, Res>): this;
    report(...args: RouterMethodParams<Req, Res>): this;
    subscribe(...args: RouterMethodParams<Req, Res>): this;
    unsubscribe(...args: RouterMethodParams<Req, Res>): this;
    trace(...args: RouterMethodParams<Req, Res>): this;
    acl(...args: RouterMethodParams<Req, Res>): this;
    connect(...args: RouterMethodParams<Req, Res>): this;
    bind(...args: RouterMethodParams<Req, Res>): this;
    unbind(...args: RouterMethodParams<Req, Res>): this;
    rebind(...args: RouterMethodParams<Req, Res>): this;
    link(...args: RouterMethodParams<Req, Res>): this;
    unlink(...args: RouterMethodParams<Req, Res>): this;
    mkcalendar(...args: RouterMethodParams<Req, Res>): this;
    propfind(...args: RouterMethodParams<Req, Res>): this;
    proppatch(...args: RouterMethodParams<Req, Res>): this;
    source(...args: RouterMethodParams<Req, Res>): this;
    all(...args: RouterMethodParams<Req, Res>): this;
    /**
     * Return the app's absolute pathname
     * based on the parent(s) that have
     * mounted it.
     *
     * For example if the application was
     * mounted as "/admin", which itself
     * was mounted as "/blog" then the
     * return value would be "/blog/admin".
     *
     */
    path(): string;
    /**
     * Push middleware to the stack
     * @param path path that middleware will handle if request URL starts with it
     * @param handler handler function
     * @param handlers the rest handler functions
     */
    use(...args: UseMethodParams<Req, Res, App>): this;
}
export {};
